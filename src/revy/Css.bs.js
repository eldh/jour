// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "bs-platform/lib/es6/list.mjs";
import * as $$String from "bs-platform/lib/es6/string.mjs";

function style(a) {
  return a;
}

function join(separator, strings) {
  var _acc = "";
  var _strings = strings;
  while(true) {
    var strings$1 = _strings;
    var acc = _acc;
    if (!strings$1) {
      return acc;
    }
    var xs = strings$1.tl;
    var x = strings$1.hd;
    if (!xs) {
      return acc + x;
    }
    _strings = xs;
    _acc = acc + (x + separator);
    continue ;
  };
}

function string_of_float(prim) {
  return prim.toString();
}

function string_of_int(prim) {
  return prim.toString();
}

function string_of_length(x) {
  if (typeof x === "string") {
    return "0";
  }
  var variant = x.NAME;
  if (variant === "pxFloat") {
    return x.VAL.toString() + "px";
  }
  if (variant === "vmax") {
    return x.VAL.toString() + "vmax";
  }
  if (variant === "vmin") {
    return x.VAL.toString() + "vmin";
  }
  if (variant === "percent") {
    return x.VAL.toString() + "%";
  }
  if (variant === "ch") {
    return x.VAL.toString() + "ch";
  }
  if (variant === "cm") {
    return x.VAL.toString() + "cm";
  }
  if (variant === "em") {
    return x.VAL.toString() + "em";
  }
  if (variant === "ex") {
    return x.VAL.toString() + "ex";
  }
  if (variant === "mm") {
    return x.VAL.toString() + "mm";
  }
  if (variant === "pt") {
    return x.VAL.toString() + "pt";
  }
  if (variant === "px") {
    return x.VAL.toString() + "px";
  }
  if (variant === "vh") {
    return x.VAL.toString() + "vh";
  }
  if (variant === "vw") {
    return x.VAL.toString() + "vw";
  }
  if (variant === "rem") {
    return x.VAL.toString() + "rem";
  }
  var match = x.VAL;
  if (match[0] === "sub") {
    return "calc(" + (string_of_length(match[1]) + (" - " + (string_of_length(match[2]) + ")")));
  } else {
    return "calc(" + (string_of_length(match[1]) + (" + " + (string_of_length(match[2]) + ")")));
  }
}

function string_of_angle(x) {
  var variant = x.NAME;
  if (variant === "turn") {
    return x.VAL.toString() + "turn";
  } else if (variant === "deg") {
    return x.VAL.toString() + "deg";
  } else if (variant === "rad") {
    return x.VAL.toString() + "rad";
  } else {
    return x.VAL.toString() + "grad";
  }
}

function string_of_rgb(r, g, b) {
  return "rgb(" + (r.toString() + (", " + (g.toString() + (", " + (b.toString() + ")")))));
}

function string_of_rgba(r, g, b, a) {
  if (a === 1) {
    return string_of_rgb(r, g, b);
  } else {
    return "rgba(" + (r.toString() + (", " + (g.toString() + (", " + (b.toString() + (", " + (a.toString() + ")")))))));
  }
}

function string_of_p3(r, g, b, a) {
  return "color(display-p3 " + (r.toString() + (" " + (g.toString() + (" " + (b.toString() + (
                    a === 1 ? ")" : " / " + (a.toString() + ")")
                  ))))));
}

function string_of_percent(x) {
  return x.VAL.toString() + "%";
}

function string_of_hsl(h, s, l) {
  return "hsl(" + (string_of_angle(h) + (", " + (string_of_percent(s) + (", " + (string_of_percent(l) + ")")))));
}

function string_of_alpha(x) {
  if (x.NAME === "num") {
    return x.VAL.toString();
  } else {
    return x.VAL.toString() + "%";
  }
}

function string_of_color(x) {
  if (typeof x === "string") {
    return "transparent";
  }
  var variant = x.NAME;
  if (variant === "p3") {
    var match = x.VAL;
    return string_of_p3(match[0], match[1], match[2], match[3]);
  }
  if (variant === "rgb") {
    var match$1 = x.VAL;
    return string_of_rgb(match$1[0], match$1[1], match$1[2]);
  }
  var match$2 = x.VAL;
  return string_of_rgba(match$2[0], match$2[1], match$2[2], match$2[3]);
}

function string_of_stops(stops) {
  return join(", ", List.map((function (param) {
                    return join(" ", {
                                hd: string_of_color(param[1]),
                                tl: {
                                  hd: string_of_length(param[0]),
                                  tl: /* [] */0
                                }
                              });
                  }), stops));
}

function string_of_linearGradient(angle, stops) {
  return "linear-gradient(" + (string_of_angle(angle) + (", " + (string_of_stops(stops) + ")")));
}

function string_of_repeatingLinearGradient(angle, stops) {
  return "repeating-linear-gradient(" + (string_of_angle(angle) + (", " + (string_of_stops(stops) + ")")));
}

function string_of_translate3d(x, y, z) {
  return "translate3d(" + (string_of_length(x) + (", " + (string_of_length(y) + (", " + (string_of_length(z) + ")")))));
}

function string_of_scale(x, y) {
  return "scale(" + (x.toString() + (", " + (y.toString() + ")")));
}

function string_of_time(t) {
  return t.toString() + "ms";
}

function string_of_overflow(x) {
  if (x === "scroll") {
    return "scroll";
  } else if (x === "initial") {
    return "initial";
  } else if (x === "hidden") {
    return "hidden";
  } else if (x === "visible") {
    return "visible";
  } else {
    return "auto";
  }
}

function string_of_visibility(x) {
  if (x === "visible") {
    return "visible";
  } else {
    return "hidden";
  }
}

function string_of_background(bg) {
  if (typeof bg === "string") {
    if (bg === "transparent") {
      return "transparent";
    } else {
      return "none";
    }
  }
  var variant = bg.NAME;
  if (variant === "repeatingRadialGradient") {
    return "repeating-radial-gradient(" + (string_of_stops(bg.VAL) + ")");
  }
  if (variant === "repeatingLinearGradient") {
    var match = bg.VAL;
    return "repeating-linear-gradient(" + (string_of_angle(match[0]) + (", " + (string_of_stops(match[1]) + ")")));
  }
  if (variant === "p3") {
    var match$1 = bg.VAL;
    return string_of_p3(match$1[0], match$1[1], match$1[2], match$1[3]);
  }
  if (variant === "rgb") {
    var match$2 = bg.VAL;
    return string_of_rgb(match$2[0], match$2[1], match$2[2]);
  }
  if (variant === "url") {
    return "url(" + (bg.VAL + ")");
  }
  if (variant === "radialGradient") {
    return "radial-gradient(" + (string_of_stops(bg.VAL) + ")");
  }
  if (variant === "linearGradient") {
    var match$3 = bg.VAL;
    return "linear-gradient(" + (string_of_angle(match$3[0]) + (", " + (string_of_stops(match$3[1]) + ")")));
  }
  var match$4 = bg.VAL;
  return string_of_rgba(match$4[0], match$4[1], match$4[2], match$4[3]);
}

function string_of_cursor(x) {
  if (x === "cell") {
    return "cell";
  } else if (x === "copy") {
    return "copy";
  } else if (x === "swResize") {
    return "sw-resize";
  } else if (x === "grab") {
    return "grab";
  } else if (x === "help") {
    return "help";
  } else if (x === "move") {
    return "move";
  } else if (x === "none") {
    return "none";
  } else if (x === "text") {
    return "text";
  } else if (x === "rowResize") {
    return "row-resize";
  } else if (x === "wait") {
    return "wait";
  } else if (x === "pointer") {
    return "pointer";
  } else if (x === "seResize") {
    return "se-resize";
  } else if (x === "zoomOut") {
    return "zoom-out";
  } else if (x === "sResize") {
    return "s-resize";
  } else if (x === "zoomIn") {
    return "zoom-in";
  } else if (x === "grabbing") {
    return "grabbing";
  } else if (x === "nsResize") {
    return "ns-resize";
  } else if (x === "nwseResize") {
    return "nwse-resize";
  } else if (x === "progress") {
    return "progress";
  } else if (x === "crosshair") {
    return "crosshair";
  } else if (x === "wResize") {
    return "w-resize";
  } else if (x === "noDrop") {
    return "no-drop";
  } else if (x === "allScroll") {
    return "all-scroll";
  } else if (x === "verticalText") {
    return "vertical-text";
  } else if (x === "nResize") {
    return "n-resize";
  } else if (x === "default") {
    return "default";
  } else if (x === "neswResize") {
    return "nesw-resize";
  } else if (x === "alias") {
    return "alias";
  } else if (x === "ewResize") {
    return "ew-resize";
  } else if (x === "eResize") {
    return "e-resize";
  } else if (x === "nwResize") {
    return "nw-resize";
  } else if (x === "contextMenu") {
    return "context-menu";
  } else if (x === "colResize") {
    return "col-resize";
  } else if (x === "notAllowed") {
    return "not-allowed";
  } else if (x === "neResize") {
    return "ne-resize";
  } else {
    return "auto";
  }
}

function string_of_fontWeight(x) {
  if (typeof x === "string") {
    if (x === "initial") {
      return "initial";
    } else if (x === "thin") {
      return "100";
    } else if (x === "semiBold") {
      return "600";
    } else if (x === "inherit_") {
      return "inherit";
    } else if (x === "bolder") {
      return "bolder";
    } else if (x === "light") {
      return "300";
    } else if (x === "extraBold") {
      return "800";
    } else if (x === "extraLight") {
      return "200";
    } else if (x === "medium") {
      return "500";
    } else if (x === "lighter") {
      return "lighter";
    } else if (x === "unset") {
      return "unset";
    } else if (x === "normal") {
      return "400";
    } else if (x === "black") {
      return "900";
    } else {
      return "700";
    }
  } else {
    return x.VAL.toString();
  }
}

function string_of_fontStyle(x) {
  if (x === "inherit_") {
    return "inherit";
  } else if (x === "italic") {
    return "italic";
  } else if (x === "unset") {
    return "unset";
  } else if (x === "oblique") {
    return "oblique";
  } else if (x === "normal") {
    return "normal";
  } else {
    return "initial";
  }
}

function string_of_flex(x) {
  if (typeof x === "string") {
    if (x === "none") {
      return "none";
    } else if (x === "initial") {
      return "initial";
    } else {
      return "auto";
    }
  } else {
    return x.VAL.toString();
  }
}

function string_of_flexBasis(x) {
  if (typeof x === "string") {
    if (x === "fill") {
      return "fill";
    } else if (x === "zero") {
      return "0";
    } else if (x === "minContent") {
      return "min-content";
    } else if (x === "fitContent") {
      return "fit-content";
    } else if (x === "maxContent") {
      return "max-content";
    } else if (x === "content") {
      return "content";
    } else {
      return "auto";
    }
  }
  var variant = x.NAME;
  if (variant === "pxFloat") {
    return x.VAL.toString() + "px";
  }
  if (variant === "vmax") {
    return x.VAL.toString() + "vmax";
  }
  if (variant === "vmin") {
    return x.VAL.toString() + "vmin";
  }
  if (variant === "percent") {
    return x.VAL.toString() + "%";
  }
  if (variant === "ch") {
    return x.VAL.toString() + "ch";
  }
  if (variant === "cm") {
    return x.VAL.toString() + "cm";
  }
  if (variant === "em") {
    return x.VAL.toString() + "em";
  }
  if (variant === "ex") {
    return x.VAL.toString() + "ex";
  }
  if (variant === "mm") {
    return x.VAL.toString() + "mm";
  }
  if (variant === "pt") {
    return x.VAL.toString() + "pt";
  }
  if (variant === "px") {
    return x.VAL.toString() + "px";
  }
  if (variant === "vh") {
    return x.VAL.toString() + "vh";
  }
  if (variant === "vw") {
    return x.VAL.toString() + "vw";
  }
  if (variant === "rem") {
    return x.VAL.toString() + "rem";
  }
  var match = x.VAL;
  if (match[0] === "sub") {
    return "calc(" + (string_of_length(match[1]) + (" - " + (string_of_length(match[2]) + ")")));
  } else {
    return "calc(" + (string_of_length(match[1]) + (" + " + (string_of_length(match[2]) + ")")));
  }
}

var Converter = {
  string_of_length: string_of_length,
  string_of_angle: string_of_angle,
  string_of_rgb: string_of_rgb,
  string_of_rgba: string_of_rgba,
  string_of_p3: string_of_p3,
  string_of_percent: string_of_percent,
  string_of_hsl: string_of_hsl,
  string_of_alpha: string_of_alpha,
  string_of_color: string_of_color,
  string_of_stops: string_of_stops,
  string_of_linearGradient: string_of_linearGradient,
  string_of_repeatingLinearGradient: string_of_repeatingLinearGradient,
  string_of_translate3d: string_of_translate3d,
  string_of_scale: string_of_scale,
  string_of_time: string_of_time,
  string_of_overflow: string_of_overflow,
  string_of_visibility: string_of_visibility,
  string_of_background: string_of_background,
  string_of_cursor: string_of_cursor,
  string_of_fontWeight: string_of_fontWeight,
  string_of_fontStyle: string_of_fontStyle,
  string_of_flex: string_of_flex,
  string_of_flexBasis: string_of_flexBasis
};

function d(property, value) {
  return {
          NAME: "declaration",
          VAL: [
            property,
            value
          ]
        };
}

function important(v) {
  if (typeof v === "string") {
    return v;
  }
  if (v.NAME !== "declaration") {
    return v;
  }
  var match = v.VAL;
  return {
          NAME: "declaration",
          VAL: [
            match[0],
            match[1] + " !important"
          ]
        };
}

function label(label$1) {
  return {
          NAME: "declaration",
          VAL: [
            "label",
            label$1
          ]
        };
}

function deg(x) {
  return {
          NAME: "deg",
          VAL: x
        };
}

function rad(x) {
  return {
          NAME: "rad",
          VAL: x
        };
}

function grad(x) {
  return {
          NAME: "grad",
          VAL: x
        };
}

function turn(x) {
  return {
          NAME: "turn",
          VAL: x
        };
}

function pct(x) {
  return {
          NAME: "percent",
          VAL: x
        };
}

function rgb(r, g, b) {
  return {
          NAME: "rgb",
          VAL: [
            r,
            g,
            b
          ]
        };
}

function rgba(r, g, b, a) {
  return {
          NAME: "rgba",
          VAL: [
            r,
            g,
            b,
            a
          ]
        };
}

function linearGradient(angle, stops) {
  return {
          NAME: "linearGradient",
          VAL: [
            angle,
            stops
          ]
        };
}

function repeatingLinearGradient(angle, stops) {
  return {
          NAME: "repeatingLinearGradient",
          VAL: [
            angle,
            stops
          ]
        };
}

function radialGradient(stops) {
  return {
          NAME: "radialGradient",
          VAL: stops
        };
}

function repeatingRadialGradient(stops) {
  return {
          NAME: "repeatingRadialGradient",
          VAL: stops
        };
}

function string_of_length_cascading(x) {
  if (typeof x === "string") {
    if (x === "zero") {
      return "0";
    } else if (x === "inherit_") {
      return "inherit";
    } else if (x === "unset") {
      return "unset";
    } else {
      return "initial";
    }
  }
  var variant = x.NAME;
  if (variant === "pxFloat") {
    return x.VAL.toString() + "px";
  }
  if (variant === "vmax") {
    return x.VAL.toString() + "vmax";
  }
  if (variant === "vmin") {
    return x.VAL.toString() + "vmin";
  }
  if (variant === "percent") {
    return x.VAL.toString() + "%";
  }
  if (variant === "ch") {
    return x.VAL.toString() + "ch";
  }
  if (variant === "cm") {
    return x.VAL.toString() + "cm";
  }
  if (variant === "em") {
    return x.VAL.toString() + "em";
  }
  if (variant === "ex") {
    return x.VAL.toString() + "ex";
  }
  if (variant === "mm") {
    return x.VAL.toString() + "mm";
  }
  if (variant === "pt") {
    return x.VAL.toString() + "pt";
  }
  if (variant === "px") {
    return x.VAL.toString() + "px";
  }
  if (variant === "vh") {
    return x.VAL.toString() + "vh";
  }
  if (variant === "vw") {
    return x.VAL.toString() + "vw";
  }
  if (variant === "rem") {
    return x.VAL.toString() + "rem";
  }
  var match = x.VAL;
  if (match[0] === "sub") {
    return "calc(" + (string_of_length(match[1]) + (" - " + (string_of_length(match[2]) + ")")));
  } else {
    return "calc(" + (string_of_length(match[1]) + (" + " + (string_of_length(match[2]) + ")")));
  }
}

function ch(x) {
  return {
          NAME: "ch",
          VAL: x
        };
}

function cm(x) {
  return {
          NAME: "cm",
          VAL: x
        };
}

function em(x) {
  return {
          NAME: "em",
          VAL: x
        };
}

function ex(x) {
  return {
          NAME: "ex",
          VAL: x
        };
}

function fr(x) {
  return {
          NAME: "fr",
          VAL: x
        };
}

function mm(x) {
  return {
          NAME: "mm",
          VAL: x
        };
}

function pt(x) {
  return {
          NAME: "pt",
          VAL: x
        };
}

function px(x) {
  return {
          NAME: "px",
          VAL: x
        };
}

function pxFloat(x) {
  return {
          NAME: "pxFloat",
          VAL: x
        };
}

function rem(x) {
  return {
          NAME: "rem",
          VAL: x
        };
}

function vh(x) {
  return {
          NAME: "vh",
          VAL: x
        };
}

function vmax(x) {
  return {
          NAME: "vmax",
          VAL: x
        };
}

function vmin(x) {
  return {
          NAME: "vmin",
          VAL: x
        };
}

function vw(x) {
  return {
          NAME: "vw",
          VAL: x
        };
}

function $neg(a, b) {
  return {
          NAME: "calc",
          VAL: [
            "sub",
            a,
            b
          ]
        };
}

function $plus(a, b) {
  return {
          NAME: "calc",
          VAL: [
            "add",
            a,
            b
          ]
        };
}

var Calc = {
  $neg: $neg,
  $plus: $plus
};

function size(x, y) {
  return {
          NAME: "size",
          VAL: [
            x,
            y
          ]
        };
}

function resize(x) {
  return d("resize", x === "none" ? "none" : (
                x === "initial" ? "initial" : (
                    x === "inherit_" ? "inherit" : (
                        x === "vertical" ? "vertical" : (
                            x === "horizontal" ? "horizontal" : (
                                x === "inline" ? "inline" : (
                                    x === "unset" ? "unset" : (
                                        x === "block" ? "block" : "both"
                                      )
                                  )
                              )
                          )
                      )
                  )
              ));
}

function count(x) {
  return {
          NAME: "count",
          VAL: x
        };
}

function cubicBesier(a, b, c, d) {
  return {
          NAME: "cubicBezier",
          VAL: [
            a,
            b,
            c,
            d
          ]
        };
}

function localUrl(x) {
  return {
          NAME: "localUrl",
          VAL: x
        };
}

function rotate(a) {
  return {
          NAME: "rotate",
          VAL: a
        };
}

function rotate3d(x, y, z, a) {
  return {
          NAME: "rotate3d",
          VAL: [
            x,
            y,
            z,
            a
          ]
        };
}

function rotateX(a) {
  return {
          NAME: "rotateX",
          VAL: a
        };
}

function rotateY(a) {
  return {
          NAME: "rotateY",
          VAL: a
        };
}

function rotateZ(a) {
  return {
          NAME: "rotateZ",
          VAL: a
        };
}

function scale(x, y) {
  return {
          NAME: "scale",
          VAL: [
            x,
            y
          ]
        };
}

function scale3d(x, y, z) {
  return {
          NAME: "scale3d",
          VAL: [
            x,
            y,
            z
          ]
        };
}

function scaleX(x) {
  return {
          NAME: "scaleX",
          VAL: x
        };
}

function scaleY(x) {
  return {
          NAME: "scaleY",
          VAL: x
        };
}

function scaleZ(x) {
  return {
          NAME: "scaleZ",
          VAL: x
        };
}

function skew(x, y) {
  return {
          NAME: "skew",
          VAL: [
            x,
            y
          ]
        };
}

function skewX(a) {
  return {
          NAME: "skewX",
          VAL: a
        };
}

function skewY(a) {
  return {
          NAME: "skewY",
          VAL: a
        };
}

function steps(i, dir) {
  return {
          NAME: "steps",
          VAL: [
            i,
            dir
          ]
        };
}

function translate(x, y) {
  return {
          NAME: "translate",
          VAL: [
            x,
            y
          ]
        };
}

function translate3d(x, y, z) {
  return {
          NAME: "translate3d",
          VAL: [
            x,
            y,
            z
          ]
        };
}

function translateX(x) {
  return {
          NAME: "translateX",
          VAL: x
        };
}

function translateY(y) {
  return {
          NAME: "translateY",
          VAL: y
        };
}

function translateZ(z) {
  return {
          NAME: "translateZ",
          VAL: z
        };
}

function url(x) {
  return {
          NAME: "url",
          VAL: x
        };
}

function display(x) {
  return d("display", x === "flex" ? "flex" : (
                x === "grid" ? "grid" : (
                    x === "none" ? "none" : (
                        x === "initial" ? "initial" : (
                            x === "inlineTable" ? "inline-table" : (
                                x === "tableRow" ? "table-row" : (
                                    x === "tableRowGroup" ? "table-row-group" : (
                                        x === "inherit_" ? "inherit" : (
                                            x === "runIn" ? "run-in" : (
                                                x === "inlineBlock" ? "inline-block" : (
                                                    x === "inlineFlex" ? "inline-flex" : (
                                                        x === "inlineGrid" ? "inline-grid" : (
                                                            x === "tableColumn" ? "table-column" : (
                                                                x === "table" ? "table" : (
                                                                    x === "inline" ? "inline" : (
                                                                        x === "tableHeaderGroup" ? "table-header-group" : (
                                                                            x === "listItem" ? "list-item" : (
                                                                                x === "unset" ? "unset" : (
                                                                                    x === "contents" ? "contents" : (
                                                                                        x === "tableCell" ? "table-cell" : (
                                                                                            x === "tableColumnGroup" ? "table-column-group" : (
                                                                                                x === "block" ? "block" : (
                                                                                                    x === "tableCaption" ? "table-caption" : "table-footer-group"
                                                                                                  )
                                                                                              )
                                                                                          )
                                                                                      )
                                                                                  )
                                                                              )
                                                                          )
                                                                      )
                                                                  )
                                                              )
                                                          )
                                                      )
                                                  )
                                              )
                                          )
                                      )
                                  )
                              )
                          )
                      )
                  )
              ));
}

function position(x) {
  return d("position", x === "initial" ? "initial" : (
                x === "inherit_" ? "inherit" : (
                    x === "fixed" ? "fixed" : (
                        x === "static" ? "static" : (
                            x === "sticky" ? "sticky" : (
                                x === "unset" ? "unset" : (
                                    x === "relative" ? "relative" : "absolute"
                                  )
                              )
                          )
                      )
                  )
              ));
}

function top(x) {
  return d("top", string_of_length_cascading(x));
}

function bottom(x) {
  return d("bottom", string_of_length_cascading(x));
}

function left(x) {
  return d("left", string_of_length_cascading(x));
}

function right(x) {
  return d("right", string_of_length_cascading(x));
}

function flex(x) {
  return d("flex", string_of_flex(x));
}

function flex3(grow, shrink, basis) {
  return d("flex", grow.toString() + (" " + (shrink.toString() + (" " + string_of_flexBasis(basis)))));
}

function flexGrow(x) {
  return d("flexGrow", x.toString());
}

function flexShrink(x) {
  return d("flexShrink", x.toString());
}

function flexBasis(x) {
  return d("flexBasis", string_of_flexBasis(x));
}

function flexDirection(x) {
  return d("flexDirection", x === "row" ? "row" : (
                x === "columnReverse" ? "column-reverse" : (
                    x === "rowReverse" ? "row-reverse" : "column"
                  )
              ));
}

function flexWrap(x) {
  return d("flexWrap", x === "wrapReverse" ? "wrap-reverse" : (
                x === "nowrap" ? "nowrap" : "wrap"
              ));
}

function order(x) {
  return d("order", x.toString());
}

function string_of_margin(x) {
  if (typeof x === "string") {
    if (x === "zero") {
      return "0";
    } else {
      return "auto";
    }
  }
  var variant = x.NAME;
  if (variant === "pxFloat") {
    return x.VAL.toString() + "px";
  }
  if (variant === "vmax") {
    return x.VAL.toString() + "vmax";
  }
  if (variant === "vmin") {
    return x.VAL.toString() + "vmin";
  }
  if (variant === "percent") {
    return x.VAL.toString() + "%";
  }
  if (variant === "ch") {
    return x.VAL.toString() + "ch";
  }
  if (variant === "cm") {
    return x.VAL.toString() + "cm";
  }
  if (variant === "em") {
    return x.VAL.toString() + "em";
  }
  if (variant === "ex") {
    return x.VAL.toString() + "ex";
  }
  if (variant === "mm") {
    return x.VAL.toString() + "mm";
  }
  if (variant === "pt") {
    return x.VAL.toString() + "pt";
  }
  if (variant === "px") {
    return x.VAL.toString() + "px";
  }
  if (variant === "vh") {
    return x.VAL.toString() + "vh";
  }
  if (variant === "vw") {
    return x.VAL.toString() + "vw";
  }
  if (variant === "rem") {
    return x.VAL.toString() + "rem";
  }
  var match = x.VAL;
  if (match[0] === "sub") {
    return "calc(" + (string_of_length(match[1]) + (" - " + (string_of_length(match[2]) + ")")));
  } else {
    return "calc(" + (string_of_length(match[1]) + (" + " + (string_of_length(match[2]) + ")")));
  }
}

function margin(x) {
  return d("margin", string_of_margin(x));
}

function margin2(v, h) {
  return d("margin", string_of_margin(v) + (" " + string_of_margin(h)));
}

function margin3(top, h, bottom) {
  return d("margin", string_of_margin(top) + (" " + (string_of_margin(h) + (" " + string_of_margin(bottom)))));
}

function margin4(top, right, bottom, left) {
  return d("margin", string_of_margin(top) + (" " + (string_of_margin(right) + (" " + (string_of_margin(bottom) + (" " + string_of_margin(left)))))));
}

function marginLeft(x) {
  return d("marginLeft", string_of_margin(x));
}

function marginRight(x) {
  return d("marginRight", string_of_margin(x));
}

function marginTop(x) {
  return d("marginTop", string_of_margin(x));
}

function marginBottom(x) {
  return d("marginBottom", string_of_margin(x));
}

function padding(x) {
  return d("padding", string_of_length(x));
}

function padding2(v, h) {
  return d("padding", string_of_length(v) + (" " + string_of_length(h)));
}

function padding3(top, h, bottom) {
  return d("padding", string_of_length(top) + (" " + (string_of_length(h) + (" " + string_of_length(bottom)))));
}

function padding4(top, right, bottom, left) {
  return d("padding", string_of_length(top) + (" " + (string_of_length(right) + (" " + (string_of_length(bottom) + (" " + string_of_length(left)))))));
}

function paddingLeft(x) {
  return d("paddingLeft", string_of_length(x));
}

function paddingRight(x) {
  return d("paddingRight", string_of_length(x));
}

function paddingTop(x) {
  return d("paddingTop", string_of_length(x));
}

function paddingBottom(x) {
  return d("paddingBottom", string_of_length(x));
}

function string_of_minmax(x) {
  if (typeof x === "string") {
    if (x === "zero") {
      return "0";
    } else if (x === "minContent") {
      return "min-content";
    } else if (x === "maxContent") {
      return "max-content";
    } else {
      return "auto";
    }
  }
  var variant = x.NAME;
  if (variant === "pxFloat") {
    return x.VAL.toString() + "px";
  }
  if (variant === "vmax") {
    return x.VAL.toString() + "vmax";
  }
  if (variant === "vmin") {
    return x.VAL.toString() + "vmin";
  }
  if (variant === "percent") {
    return x.VAL.toString() + "%";
  }
  if (variant === "ch") {
    return x.VAL.toString() + "ch";
  }
  if (variant === "cm") {
    return x.VAL.toString() + "cm";
  }
  if (variant === "em") {
    return x.VAL.toString() + "em";
  }
  if (variant === "ex") {
    return x.VAL.toString() + "ex";
  }
  if (variant === "fr") {
    return x.VAL.toString() + "fr";
  }
  if (variant === "mm") {
    return x.VAL.toString() + "mm";
  }
  if (variant === "pt") {
    return x.VAL.toString() + "pt";
  }
  if (variant === "px") {
    return x.VAL.toString() + "px";
  }
  if (variant === "vh") {
    return x.VAL.toString() + "vh";
  }
  if (variant === "vw") {
    return x.VAL.toString() + "vw";
  }
  if (variant === "rem") {
    return x.VAL.toString() + "rem";
  }
  var match = x.VAL;
  if (match[0] === "sub") {
    return "calc(" + (string_of_length(match[1]) + (" - " + (string_of_length(match[2]) + ")")));
  } else {
    return "calc(" + (string_of_length(match[1]) + (" + " + (string_of_length(match[2]) + ")")));
  }
}

function string_of_dimension(x) {
  if (typeof x === "string") {
    if (x === "none") {
      return "none";
    } else if (x === "zero") {
      return "0";
    } else if (x === "minContent") {
      return "min-content";
    } else if (x === "maxContent") {
      return "max-content";
    } else {
      return "auto";
    }
  }
  var variant = x.NAME;
  if (variant === "pxFloat") {
    return x.VAL.toString() + "px";
  }
  if (variant === "vmax") {
    return x.VAL.toString() + "vmax";
  }
  if (variant === "vmin") {
    return x.VAL.toString() + "vmin";
  }
  if (variant === "minmax") {
    var match = x.VAL;
    return "minmax(" + (string_of_minmax(match[0]) + ("," + (string_of_minmax(match[1]) + ")")));
  }
  if (variant === "percent") {
    return x.VAL.toString() + "%";
  }
  if (variant === "ch") {
    return x.VAL.toString() + "ch";
  }
  if (variant === "cm") {
    return x.VAL.toString() + "cm";
  }
  if (variant === "em") {
    return x.VAL.toString() + "em";
  }
  if (variant === "ex") {
    return x.VAL.toString() + "ex";
  }
  if (variant === "fr") {
    return x.VAL.toString() + "fr";
  }
  if (variant === "mm") {
    return x.VAL.toString() + "mm";
  }
  if (variant === "pt") {
    return x.VAL.toString() + "pt";
  }
  if (variant === "px") {
    return x.VAL.toString() + "px";
  }
  if (variant === "vh") {
    return x.VAL.toString() + "vh";
  }
  if (variant === "vw") {
    return x.VAL.toString() + "vw";
  }
  if (variant === "rem") {
    return x.VAL.toString() + "rem";
  }
  var match$1 = x.VAL;
  if (match$1[0] === "sub") {
    return "calc(" + (string_of_length(match$1[1]) + (" - " + (string_of_length(match$1[2]) + ")")));
  } else {
    return "calc(" + (string_of_length(match$1[1]) + (" + " + (string_of_length(match$1[2]) + ")")));
  }
}

function width(x) {
  return d("width", string_of_dimension(x));
}

function height(x) {
  return d("height", string_of_dimension(x));
}

function minWidth(x) {
  return d("minWidth", string_of_dimension(x));
}

function maxWidth(x) {
  return d("maxWidth", string_of_dimension(x));
}

function minHeight(x) {
  return d("minHeight", string_of_dimension(x));
}

function maxHeight(x) {
  return d("maxHeight", string_of_dimension(x));
}

function gridAutoDirectionToJs(x) {
  if (x === "initial") {
    return "initial";
  } else if (x === "inherit_") {
    return "inherit";
  } else if (x === "columnDense") {
    return "column dense";
  } else if (x === "rowDense") {
    return "row dense";
  } else if (x === "row") {
    return "row";
  } else if (x === "unset") {
    return "unset";
  } else {
    return "column";
  }
}

function gridAutoFlow(direction) {
  return d("gridAutoFlow", gridAutoDirectionToJs(direction));
}

function repeatValueToJs(x) {
  if (typeof x === "string") {
    if (x === "autoFill") {
      return "auto-fill";
    } else {
      return "auto-fit";
    }
  } else {
    return x.VAL.toString();
  }
}

function gridLengthToJs(x) {
  if (typeof x === "string") {
    if (x === "zero") {
      return "0";
    } else if (x === "minContent") {
      return "min-content";
    } else if (x === "maxContent") {
      return "max-content";
    } else {
      return "auto";
    }
  }
  var variant = x.NAME;
  if (variant === "pxFloat") {
    return x.VAL.toString() + "px";
  }
  if (variant === "vmax") {
    return x.VAL.toString() + "vmax";
  }
  if (variant === "vmin") {
    return x.VAL.toString() + "vmin";
  }
  if (variant === "minmax") {
    var match = x.VAL;
    return "minmax(" + (string_of_minmax(match[0]) + ("," + (string_of_minmax(match[1]) + ")")));
  }
  if (variant === "percent") {
    return x.VAL.toString() + "%";
  }
  if (variant === "ch") {
    return x.VAL.toString() + "ch";
  }
  if (variant === "cm") {
    return x.VAL.toString() + "cm";
  }
  if (variant === "em") {
    return x.VAL.toString() + "em";
  }
  if (variant === "ex") {
    return x.VAL.toString() + "ex";
  }
  if (variant === "fr") {
    return x.VAL.toString() + "fr";
  }
  if (variant === "mm") {
    return x.VAL.toString() + "mm";
  }
  if (variant === "pt") {
    return x.VAL.toString() + "pt";
  }
  if (variant === "px") {
    return x.VAL.toString() + "px";
  }
  if (variant === "vh") {
    return x.VAL.toString() + "vh";
  }
  if (variant === "vw") {
    return x.VAL.toString() + "vw";
  }
  if (variant === "rem") {
    return x.VAL.toString() + "rem";
  }
  if (variant === "repeat") {
    var match$1 = x.VAL;
    return "repeat(" + (repeatValueToJs(match$1[0]) + (", " + (string_of_dimension(match$1[1]) + ")")));
  }
  var match$2 = x.VAL;
  if (match$2[0] === "sub") {
    return "calc(" + (string_of_length(match$2[1]) + (" - " + (string_of_length(match$2[2]) + ")")));
  } else {
    return "calc(" + (string_of_length(match$2[1]) + (" + " + (string_of_length(match$2[2]) + ")")));
  }
}

function string_of_dimensions(dimensions) {
  return $$String.concat(" ", List.map(gridLengthToJs, dimensions));
}

function gridTemplateColumns(dimensions) {
  return d("gridTemplateColumns", string_of_dimensions(dimensions));
}

function gridTemplateRows(dimensions) {
  return d("gridTemplateRows", string_of_dimensions(dimensions));
}

function gridAutoColumns(dimensions) {
  return d("gridAutoColumns", string_of_dimension(dimensions));
}

function gridAutoRows(dimensions) {
  return d("gridAutoRows", string_of_dimension(dimensions));
}

function gridColumn(start, end$prime) {
  return d("gridColumn", start.toString() + (" / " + end$prime.toString()));
}

function gridRow(start, end$prime) {
  return d("gridRow", start.toString() + (" / " + end$prime.toString()));
}

function gridColumnStart(n) {
  return d("gridColumnStart", n.toString());
}

function gridColumnEnd(n) {
  return d("gridColumnEnd", n.toString());
}

function gridRowStart(n) {
  return d("gridRowStart", n.toString());
}

function gridRowEnd(n) {
  return d("gridRowEnd", n.toString());
}

function gridColumnGap(n) {
  return d("gridColumnGap", string_of_length(n));
}

function gridRowGap(n) {
  return d("gridRowGap", string_of_length(n));
}

function gridGap(n) {
  return d("gridGap", string_of_length(n));
}

function string_of_align(x) {
  if (x === "stretch") {
    return "stretch";
  } else if (x === "center") {
    return "center";
  } else if (x === "baseline") {
    return "baseline";
  } else if (x === "flexStart") {
    return "flex-start";
  } else if (x === "flexEnd") {
    return "flex-end";
  } else {
    return "auto";
  }
}

function alignItems(x) {
  return d("alignItems", string_of_align(x));
}

function alignSelf(x) {
  return d("alignSelf", string_of_align(x));
}

function string_of_justify(x) {
  if (x === "spaceAround") {
    return "space-around";
  } else if (x === "stretch") {
    return "stretch";
  } else if (x === "center") {
    return "center";
  } else if (x === "spaceBetween") {
    return "space-between";
  } else if (x === "flexStart") {
    return "flex-start";
  } else if (x === "flexEnd") {
    return "flex-end";
  } else {
    return "space-evenly";
  }
}

function justifyContent(x) {
  return d("justifyContent", string_of_justify(x));
}

function justifySelf(x) {
  return d("justifySelf", string_of_justify(x));
}

function alignContent(x) {
  return d("alignContent", string_of_justify(x));
}

function boxSizing(x) {
  return d("boxSizing", x === "initial" ? "initial" : (
                x === "inherit_" ? "inherit" : (
                    x === "borderBox" ? "border-box" : (
                        x === "unset" ? "unset" : "content-box"
                      )
                  )
              ));
}

function $$float(x) {
  return d("float", x === "none" ? "none" : (
                x === "right" ? "right" : "left"
              ));
}

function clear(x) {
  return d("clear", x === "left" ? "left" : (
                x === "right" ? "right" : "both"
              ));
}

function overflow(x) {
  return d("overflow", string_of_overflow(x));
}

function overflowX(x) {
  return d("overflowX", string_of_overflow(x));
}

function overflowY(x) {
  return d("overflowY", string_of_overflow(x));
}

function zIndex(x) {
  return d("zIndex", x.toString());
}

function contentRule(x) {
  return d("content", "\"" + x + "\"");
}

function columnCount(x) {
  return d("columnCount", typeof x === "string" ? (
                x === "initial" ? "initial" : (
                    x === "inherit_" ? "inherit" : (
                        x === "unset" ? "unset" : "auto"
                      )
                  )
              ) : x.VAL.toString());
}

function direction(x) {
  return d("direction", x === "inherit_" ? "inherit" : (
                x === "ltr" ? "ltr" : (
                    x === "rtl" ? "rtl" : (
                        x === "unset" ? "unset" : "initial"
                      )
                  )
              ));
}

function string_of_filter(x) {
  if (typeof x === "string") {
    if (x === "initial") {
      return "initial";
    } else if (x === "inherit_") {
      return "inherit";
    } else if (x === "unset") {
      return "unset";
    } else {
      return "none";
    }
  }
  var variant = x.NAME;
  if (variant !== "dropShadow") {
    if (variant === "brightness") {
      return "brightness(" + (x.VAL.toString() + "%)");
    } else if (variant === "opacity") {
      return "opacity(" + (x.VAL.toString() + "%)");
    } else if (variant === "grayscale") {
      return "grayscale(" + (x.VAL.toString() + "%)");
    } else if (variant === "sepia") {
      return "sepia(" + (x.VAL.toString() + "%)");
    } else if (variant === "saturate") {
      return "saturate(" + (x.VAL.toString() + "%)");
    } else if (variant === "url") {
      return "url(" + (x.VAL + ")");
    } else if (variant === "invert") {
      return "invert(" + (x.VAL.toString() + "%)");
    } else if (variant === "contrast") {
      return "contrast(" + (x.VAL.toString() + "%)");
    } else if (variant === "hueRotate") {
      return "hue-rotate(" + (string_of_angle(x.VAL) + ")");
    } else {
      return "blur(" + (string_of_length(x.VAL) + ")");
    }
  }
  var match = x.VAL;
  return "drop-shadow(" + (string_of_length(match[0]) + (" " + (string_of_length(match[1]) + (" " + (string_of_length(match[2]) + (" " + (string_of_color(match[3]) + ")")))))));
}

function filter(x) {
  return d("filter", join(" ", List.map(string_of_filter, x)));
}

function backfaceVisibility(x) {
  return d("backfaceVisibility", string_of_visibility(x));
}

function visibility(x) {
  return d("visibility", string_of_visibility(x));
}

function boxShadow(xOpt, yOpt, blurOpt, spreadOpt, insetOpt, color) {
  var x = xOpt !== undefined ? xOpt : "zero";
  var y = yOpt !== undefined ? yOpt : "zero";
  var blur = blurOpt !== undefined ? blurOpt : "zero";
  var spread = spreadOpt !== undefined ? spreadOpt : "zero";
  var inset = insetOpt !== undefined ? insetOpt : false;
  return {
          NAME: "shadow",
          VAL: string_of_length(x) + (" " + (string_of_length(y) + (" " + (string_of_length(blur) + (" " + (string_of_length(spread) + (" " + (string_of_color(color) + (" " + (
                              inset ? "inset" : ""
                            ))))))))))
        };
}

function string_of_shadow(x) {
  return x.VAL;
}

function boxShadows(shadows) {
  return d("boxShadow", join(", ", List.map(string_of_shadow, shadows)));
}

function string_of_borderstyle(x) {
  if (x === "solid") {
    return "solid";
  } else if (x === "dashed") {
    return "dashed";
  } else if (x === "dotted") {
    return "dotted";
  } else {
    return "none";
  }
}

function border(px, style, color) {
  return d("border", string_of_length(px) + (" " + (string_of_borderstyle(style) + (" " + string_of_color(color)))));
}

function borderWidth(x) {
  return d("borderWidth", string_of_length(x));
}

function borderStyle(x) {
  return d("borderStyle", string_of_borderstyle(x));
}

function borderColor(x) {
  return d("borderColor", string_of_color(x));
}

function borderLeft(px, style, color) {
  return d("borderLeft", string_of_length(px) + (" " + (string_of_borderstyle(style) + (" " + string_of_color(color)))));
}

function borderLeftWidth(x) {
  return d("borderLeftWidth", string_of_length(x));
}

function borderLeftStyle(x) {
  return d("borderLeftStyle", string_of_borderstyle(x));
}

function borderLeftColor(x) {
  return d("borderLeftColor", string_of_color(x));
}

function borderRight(px, style, color) {
  return d("borderRight", string_of_length(px) + (" " + (string_of_borderstyle(style) + (" " + string_of_color(color)))));
}

function borderRightWidth(x) {
  return d("borderRightWidth", string_of_length(x));
}

function borderRightColor(x) {
  return d("borderRightColor", string_of_color(x));
}

function borderRightStyle(x) {
  return d("borderRightStyle", string_of_borderstyle(x));
}

function borderTop(px, style, color) {
  return d("borderTop", string_of_length(px) + (" " + (string_of_borderstyle(style) + (" " + string_of_color(color)))));
}

function borderTopWidth(x) {
  return d("borderTopWidth", string_of_length(x));
}

function borderTopStyle(x) {
  return d("borderTopStyle", string_of_borderstyle(x));
}

function borderTopColor(x) {
  return d("borderTopColor", string_of_color(x));
}

function borderBottom(px, style, color) {
  return d("borderBottom", string_of_length(px) + (" " + (string_of_borderstyle(style) + (" " + string_of_color(color)))));
}

function borderBottomWidth(x) {
  return d("borderBottomWidth", string_of_length(x));
}

function borderBottomStyle(x) {
  return d("borderBottomStyle", string_of_borderstyle(x));
}

function borderBottomColor(x) {
  return d("borderBottomColor", string_of_color(x));
}

function borderRadius(i) {
  return d("borderRadius", string_of_length(i));
}

function borderTopLeftRadius(i) {
  return d("borderTopLeftRadius", string_of_length(i));
}

function borderTopRightRadius(i) {
  return d("borderTopRightRadius", string_of_length(i));
}

function borderBottomLeftRadius(i) {
  return d("borderBottomLeftRadius", string_of_length(i));
}

function borderBottomRightRadius(i) {
  return d("borderBottomRightRadius", string_of_length(i));
}

function tableLayout(x) {
  return d("tableLayout", x === "fixed" ? "fixed" : "auto");
}

function borderCollapse(x) {
  return d("borderCollapse", x === "separate" ? "separate" : "collapse");
}

function borderSpacing(i) {
  return d("borderSpacing", string_of_length(i));
}

function background(x) {
  return d("background", string_of_background(x));
}

function backgrounds(bg) {
  return d("background", join(", ", List.map(string_of_background, bg)));
}

function backgroundColor(x) {
  return d("backgroundColor", string_of_color(x));
}

function backgroundImage(x) {
  var tmp;
  if (typeof x === "string") {
    tmp = "none";
  } else {
    var variant = x.NAME;
    if (variant === "repeatingLinearGradient") {
      var match = x.VAL;
      tmp = string_of_repeatingLinearGradient(match[0], match[1]);
    } else if (variant === "url") {
      tmp = "url(" + (x.VAL + ")");
    } else if (variant === "radialGradient") {
      tmp = "radial-gradient(" + (string_of_stops(x.VAL) + ")");
    } else if (variant === "linearGradient") {
      var match$1 = x.VAL;
      tmp = string_of_linearGradient(match$1[0], match$1[1]);
    } else {
      tmp = "repeating-radial-gradient(" + (string_of_stops(x.VAL) + ")");
    }
  }
  return d("backgroundImage", tmp);
}

function backgroundAttachment(x) {
  return d("backgroundAttachment", x === "local" ? "local" : (
                x === "fixed" ? "fixed" : "scroll"
              ));
}

function backgroundClip(x) {
  return d("backgroundClip", x === "borderBox" ? "border-box" : (
                x === "paddingBox" ? "padding-box" : "content-box"
              ));
}

function backgroundOrigin(x) {
  return d("backgroundOrigin", x === "borderBox" ? "border-box" : (
                x === "paddingBox" ? "padding-box" : "content-box"
              ));
}

function backgroundPosition(x, y) {
  return d("backgroundPosition", string_of_length(x) + (" " + string_of_length(y)));
}

function backgroundRepeat(x) {
  return d("backgroundRepeat", x === "repeat" ? "repeat" : (
                x === "repeatX" ? "repeat-x" : (
                    x === "repeatY" ? "repeat-y" : "no-repeat"
                  )
              ));
}

function backgroundSize(x) {
  var tmp;
  if (typeof x === "string") {
    tmp = x === "cover" ? "cover" : (
        x === "contain" ? "contain" : "auto"
      );
  } else {
    var match = x.VAL;
    tmp = string_of_length(match[0]) + (" " + string_of_length(match[1]));
  }
  return d("backgroundSize", tmp);
}

function cursor(x) {
  return d("cursor", string_of_cursor(x));
}

function clipPath(x) {
  return d("clipPath", "url(" + (x.VAL + ")"));
}

function string_of_listStyleType(x) {
  if (x === "none") {
    return "none";
  } else if (x === "circle") {
    return "circle";
  } else if (x === "lowerGreek") {
    return "lower-greek";
  } else if (x === "square") {
    return "square";
  } else if (x === "lowerAlpha") {
    return "lower-alpha";
  } else if (x === "upperAlpha") {
    return "upper-alpha";
  } else if (x === "decimal") {
    return "decimal";
  } else if (x === "lowerRoman") {
    return "lower-roman";
  } else if (x === "lowerLatin") {
    return "lower-latin";
  } else if (x === "upperRoman") {
    return "upper-roman";
  } else if (x === "upperLatin") {
    return "upper-latin";
  } else {
    return "disc";
  }
}

function string_of_listStylePosition(x) {
  if (x === "inside") {
    return "inside";
  } else {
    return "outside";
  }
}

function string_of_listStyleImage(x) {
  if (typeof x === "string") {
    return "none";
  } else {
    return "url(" + (x.VAL + ")");
  }
}

function listStyle(style, pos, img) {
  return d("listStyle", string_of_listStyleType(style) + (" " + (string_of_listStylePosition(pos) + (" " + string_of_listStyleImage(img)))));
}

function listStyleType(x) {
  return d("listStyleType", string_of_listStyleType(x));
}

function listStylePosition(x) {
  return d("listStylePosition", string_of_listStylePosition(x));
}

function listStyleImage(x) {
  return d("listStyleImage", string_of_listStyleImage(x));
}

function opacity(x) {
  return d("opacity", x.toString());
}

function string_of_outlineStyle(x) {
  if (x === "hidden") {
    return "hidden";
  } else if (x === "ridge") {
    return "ridge";
  } else if (x === "solid") {
    return "solid";
  } else if (x === "outset") {
    return "outset";
  } else if (x === "groove") {
    return "grove";
  } else if (x === "dashed") {
    return "dashed";
  } else if (x === "dotted") {
    return "dotted";
  } else if (x === "double") {
    return "double";
  } else if (x === "inset") {
    return "inset";
  } else {
    return "none";
  }
}

function outline(size, style, color) {
  return d("outline", string_of_length(size) + (" " + (string_of_outlineStyle(style) + (" " + string_of_color(color)))));
}

function outlineStyle(x) {
  return d("outlineStyle", string_of_outlineStyle(x));
}

function outlineWidth(x) {
  return d("outlineWidth", string_of_length(x));
}

function outlineColor(x) {
  return d("outlineColor", string_of_color(x));
}

function outlineOffset(x) {
  return d("outlineOffset", string_of_length(x));
}

function color(x) {
  return d("color", string_of_color(x));
}

function fontFamily(x) {
  return d("fontFamily", x);
}

function fontSize(x) {
  return d("fontSize", string_of_length_cascading(x));
}

function fontVariant(x) {
  return d("fontVariant", x === "inherit_" ? "inherit" : (
                x === "smallCaps" ? "small-caps" : (
                    x === "unset" ? "unset" : (
                        x === "normal" ? "normal" : "initial"
                      )
                  )
              ));
}

function fontStyle(x) {
  return d("fontStyle", string_of_fontStyle(x));
}

function fontWeight(x) {
  return d("fontWeight", string_of_fontWeight(x));
}

function lineHeight(x) {
  var tmp;
  if (typeof x === "string") {
    tmp = x === "initial" ? "initial" : (
        x === "zero" ? "0" : (
            x === "inherit_" ? "inherit" : (
                x === "unset" ? "unset" : (
                    x === "normal" ? "normal" : "auto"
                  )
              )
          )
      );
  } else {
    var variant = x.NAME;
    if (variant === "pxFloat") {
      tmp = x.VAL.toString() + "px";
    } else if (variant === "vmax") {
      tmp = x.VAL.toString() + "vmax";
    } else if (variant === "vmin") {
      tmp = x.VAL.toString() + "vmin";
    } else if (variant === "percent") {
      tmp = x.VAL.toString() + "%";
    } else if (variant === "ch") {
      tmp = x.VAL.toString() + "ch";
    } else if (variant === "cm") {
      tmp = x.VAL.toString() + "cm";
    } else if (variant === "em") {
      tmp = x.VAL.toString() + "em";
    } else if (variant === "ex") {
      tmp = x.VAL.toString() + "ex";
    } else if (variant === "mm") {
      tmp = x.VAL.toString() + "mm";
    } else if (variant === "pt") {
      tmp = x.VAL.toString() + "pt";
    } else if (variant === "px") {
      tmp = x.VAL.toString() + "px";
    } else if (variant === "vh") {
      tmp = x.VAL.toString() + "vh";
    } else if (variant === "vw") {
      tmp = x.VAL.toString() + "vw";
    } else if (variant === "abs") {
      tmp = x.VAL.toString();
    } else if (variant === "rem") {
      tmp = x.VAL.toString() + "rem";
    } else {
      var match = x.VAL;
      tmp = match[0] === "sub" ? "calc(" + (string_of_length(match[1]) + (" - " + (string_of_length(match[2]) + ")"))) : "calc(" + (string_of_length(match[1]) + (" + " + (string_of_length(match[2]) + ")")));
    }
  }
  return d("lineHeight", tmp);
}

function letterSpacing(x) {
  var tmp;
  if (typeof x === "string") {
    tmp = x === "initial" ? "initial" : (
        x === "zero" ? "0" : (
            x === "inherit_" ? "inherit" : (
                x === "unset" ? "unset" : (
                    x === "normal" ? "normal" : "auto"
                  )
              )
          )
      );
  } else {
    var variant = x.NAME;
    if (variant === "pxFloat") {
      tmp = x.VAL.toString() + "px";
    } else if (variant === "vmax") {
      tmp = x.VAL.toString() + "vmax";
    } else if (variant === "vmin") {
      tmp = x.VAL.toString() + "vmin";
    } else if (variant === "percent") {
      tmp = x.VAL.toString() + "%";
    } else if (variant === "ch") {
      tmp = x.VAL.toString() + "ch";
    } else if (variant === "cm") {
      tmp = x.VAL.toString() + "cm";
    } else if (variant === "em") {
      tmp = x.VAL.toString() + "em";
    } else if (variant === "ex") {
      tmp = x.VAL.toString() + "ex";
    } else if (variant === "mm") {
      tmp = x.VAL.toString() + "mm";
    } else if (variant === "pt") {
      tmp = x.VAL.toString() + "pt";
    } else if (variant === "px") {
      tmp = x.VAL.toString() + "px";
    } else if (variant === "vh") {
      tmp = x.VAL.toString() + "vh";
    } else if (variant === "vw") {
      tmp = x.VAL.toString() + "vw";
    } else if (variant === "rem") {
      tmp = x.VAL.toString() + "rem";
    } else {
      var match = x.VAL;
      tmp = match[0] === "sub" ? "calc(" + (string_of_length(match[1]) + (" - " + (string_of_length(match[2]) + ")"))) : "calc(" + (string_of_length(match[1]) + (" + " + (string_of_length(match[2]) + ")")));
    }
  }
  return d("letterSpacing", tmp);
}

function textAlign(x) {
  return d("textAlign", x === "initial" ? "initial" : (
                x === "inherit_" ? "inherit" : (
                    x === "right" ? "right" : (
                        x === "justify" ? "justify" : (
                            x === "center" ? "center" : (
                                x === "unset" ? "unset" : "left"
                              )
                          )
                      )
                  )
              ));
}

function textDecoration(x) {
  return d("textDecoration", x === "none" ? "none" : (
                x === "initial" ? "initial" : (
                    x === "inherit_" ? "inherit" : (
                        x === "underline" ? "underline" : (
                            x === "lineThrough" ? "line-through" : (
                                x === "unset" ? "unset" : "overline"
                              )
                          )
                      )
                  )
              ));
}

function textDecorationColor(x) {
  return d("textDecorationColor", string_of_color(x));
}

function textDecorationStyle(x) {
  return d("textDecorationStyle", x === "wavy" ? "wavy" : (
                x === "inherit_" ? "inherit" : (
                    x === "solid" ? "solid" : (
                        x === "dashed" ? "dashed" : (
                            x === "unset" ? "unset" : (
                                x === "dotted" ? "dotted" : (
                                    x === "double" ? "double" : "initial"
                                  )
                              )
                          )
                      )
                  )
              ));
}

function textIndent(x) {
  return d("textIndent", string_of_length(x));
}

function textOverflow(x) {
  return d("textOverflow", typeof x === "string" ? (
                x === "initial" ? "initial" : (
                    x === "inherit_" ? "inherit" : (
                        x === "ellipsis" ? "ellipsis" : (
                            x === "unset" ? "unset" : "clip"
                          )
                      )
                  )
              ) : x.VAL);
}

function textShadow(xOpt, yOpt, blurOpt, color) {
  var x = xOpt !== undefined ? xOpt : "zero";
  var y = yOpt !== undefined ? yOpt : "zero";
  var blur = blurOpt !== undefined ? blurOpt : "zero";
  return {
          NAME: "textShadow",
          VAL: string_of_length(x) + (" " + (string_of_length(y) + (" " + (string_of_length(blur) + (" " + string_of_color(color))))))
        };
}

function string_of_textShadow(x) {
  return x.VAL;
}

function textShadows(textShadows$1) {
  return d("textShadow", join(", ", List.map(string_of_textShadow, textShadows$1)));
}

function textTransform(x) {
  return d("textTransform", x === "initial" ? "initial" : (
                x === "inherit_" ? "inherit" : (
                    x === "capitalize" ? "capitalize" : (
                        x === "lowercase" ? "lowercase" : (
                            x === "uppercase" ? "uppercase" : (
                                x === "unset" ? "unset" : "none"
                              )
                          )
                      )
                  )
              ));
}

function userSelect(x) {
  return d("userSelect", x === "none" ? "none" : (
                x === "initial" ? "initial" : (
                    x === "text" ? "text" : (
                        x === "inherit_" ? "inherit" : (
                            x === "all" ? "all" : (
                                x === "unset" ? "unset" : "auto"
                              )
                          )
                      )
                  )
              ));
}

function verticalAlign(x) {
  var tmp;
  if (typeof x === "string") {
    tmp = x === "initial" ? "initial" : (
        x === "middle" ? "middle" : (
            x === "zero" ? "0" : (
                x === "inherit_" ? "inherit" : (
                    x === "bottom" ? "bottom" : (
                        x === "sub" ? "sub" : (
                            x === "top" ? "top" : (
                                x === "super" ? "super" : (
                                    x === "baseline" ? "baseline" : (
                                        x === "textBottom" ? "text-bottom" : (
                                            x === "textTop" ? "text-top" : (
                                                x === "unset" ? "unset" : "auto"
                                              )
                                          )
                                      )
                                  )
                              )
                          )
                      )
                  )
              )
          )
      );
  } else {
    var variant = x.NAME;
    if (variant === "pxFloat") {
      tmp = x.VAL.toString() + "px";
    } else if (variant === "vmax") {
      tmp = x.VAL.toString() + "vmax";
    } else if (variant === "vmin") {
      tmp = x.VAL.toString() + "vmin";
    } else if (variant === "percent") {
      tmp = x.VAL.toString() + "%";
    } else if (variant === "ch") {
      tmp = x.VAL.toString() + "ch";
    } else if (variant === "cm") {
      tmp = x.VAL.toString() + "cm";
    } else if (variant === "em") {
      tmp = x.VAL.toString() + "em";
    } else if (variant === "ex") {
      tmp = x.VAL.toString() + "ex";
    } else if (variant === "mm") {
      tmp = x.VAL.toString() + "mm";
    } else if (variant === "pt") {
      tmp = x.VAL.toString() + "pt";
    } else if (variant === "px") {
      tmp = x.VAL.toString() + "px";
    } else if (variant === "vh") {
      tmp = x.VAL.toString() + "vh";
    } else if (variant === "vw") {
      tmp = x.VAL.toString() + "vw";
    } else if (variant === "rem") {
      tmp = x.VAL.toString() + "rem";
    } else {
      var match = x.VAL;
      tmp = match[0] === "sub" ? "calc(" + (string_of_length(match[1]) + (" - " + (string_of_length(match[2]) + ")"))) : "calc(" + (string_of_length(match[1]) + (" + " + (string_of_length(match[2]) + ")")));
    }
  }
  return d("verticalAlign", tmp);
}

function whiteSpace(x) {
  return d("whiteSpace", x === "inherit_" ? "inherit" : (
                x === "pre" ? "pre" : (
                    x === "preLine" ? "pre-line" : (
                        x === "unset" ? "unset" : (
                            x === "preWrap" ? "pre-wrap" : (
                                x === "normal" ? "normal" : (
                                    x === "nowrap" ? "nowrap" : "initial"
                                  )
                              )
                          )
                      )
                  )
              ));
}

function wordBreak(x) {
  return d("wordBreak", x === "inherit_" ? "inherit" : (
                x === "breakAll" ? "break-all" : (
                    x === "unset" ? "unset" : (
                        x === "normal" ? "normal" : (
                            x === "keepAll" ? "keep-all" : "initial"
                          )
                      )
                  )
              ));
}

function wordSpacing(x) {
  var tmp;
  if (typeof x === "string") {
    tmp = x === "initial" ? "initial" : (
        x === "zero" ? "0" : (
            x === "inherit_" ? "inherit" : (
                x === "unset" ? "unset" : (
                    x === "normal" ? "normal" : "auto"
                  )
              )
          )
      );
  } else {
    var variant = x.NAME;
    if (variant === "pxFloat") {
      tmp = x.VAL.toString() + "px";
    } else if (variant === "vmax") {
      tmp = x.VAL.toString() + "vmax";
    } else if (variant === "vmin") {
      tmp = x.VAL.toString() + "vmin";
    } else if (variant === "percent") {
      tmp = x.VAL.toString() + "%";
    } else if (variant === "ch") {
      tmp = x.VAL.toString() + "ch";
    } else if (variant === "cm") {
      tmp = x.VAL.toString() + "cm";
    } else if (variant === "em") {
      tmp = x.VAL.toString() + "em";
    } else if (variant === "ex") {
      tmp = x.VAL.toString() + "ex";
    } else if (variant === "mm") {
      tmp = x.VAL.toString() + "mm";
    } else if (variant === "pt") {
      tmp = x.VAL.toString() + "pt";
    } else if (variant === "px") {
      tmp = x.VAL.toString() + "px";
    } else if (variant === "vh") {
      tmp = x.VAL.toString() + "vh";
    } else if (variant === "vw") {
      tmp = x.VAL.toString() + "vw";
    } else if (variant === "rem") {
      tmp = x.VAL.toString() + "rem";
    } else {
      var match = x.VAL;
      tmp = match[0] === "sub" ? "calc(" + (string_of_length(match[1]) + (" - " + (string_of_length(match[2]) + ")"))) : "calc(" + (string_of_length(match[1]) + (" + " + (string_of_length(match[2]) + ")")));
    }
  }
  return d("wordSpacing", tmp);
}

function wordWrap(x) {
  return d("wordWrap", x === "inherit_" ? "inherit" : (
                x === "unset" ? "unset" : (
                    x === "normal" ? "normal" : (
                        x === "breakWord" ? "break-word" : "initial"
                      )
                  )
              ));
}

function string_of_pointerEvents(x) {
  if (x === "none") {
    return "none";
  } else {
    return "auto";
  }
}

function pointerEvents(x) {
  return d("pointerEvents", string_of_pointerEvents(x));
}

function string_of_transform(x) {
  var variant = x.NAME;
  if (variant === "translate") {
    var match = x.VAL;
    return "translate(" + (string_of_length(match[0]) + (", " + (string_of_length(match[1]) + ")")));
  }
  if (variant === "rotate") {
    return "rotate(" + (string_of_angle(x.VAL) + ")");
  }
  if (variant === "skew") {
    var match$1 = x.VAL;
    return "skew(" + (string_of_angle(match$1[0]) + (", " + (string_of_angle(match$1[1]) + ")")));
  }
  if (variant === "scale3d") {
    var match$2 = x.VAL;
    return "scale3d(" + (match$2[0].toString() + (", " + (match$2[1].toString() + (", " + (match$2[2].toString() + ")")))));
  }
  if (variant === "rotateX") {
    return "rotateX(" + (string_of_angle(x.VAL) + ")");
  }
  if (variant === "rotateY") {
    return "rotateY(" + (string_of_angle(x.VAL) + ")");
  }
  if (variant === "rotateZ") {
    return "rotateZ(" + (string_of_angle(x.VAL) + ")");
  }
  if (variant === "scale") {
    var match$3 = x.VAL;
    return string_of_scale(match$3[0], match$3[1]);
  }
  if (variant === "skewX") {
    return "skewX(" + (string_of_angle(x.VAL) + ")");
  }
  if (variant === "skewY") {
    return "skewY(" + (string_of_angle(x.VAL) + ")");
  }
  if (variant === "translateX") {
    return "translateX(" + (string_of_length(x.VAL) + ")");
  }
  if (variant === "translateY") {
    return "translateY(" + (string_of_length(x.VAL) + ")");
  }
  if (variant === "translateZ") {
    return "translateZ(" + (string_of_length(x.VAL) + ")");
  }
  if (variant === "rotate3d") {
    var match$4 = x.VAL;
    return "rotate3d(" + (match$4[0].toString() + (", " + (match$4[1].toString() + (", " + (match$4[2].toString() + (", " + (string_of_angle(match$4[3]) + ")")))))));
  }
  if (variant !== "translate3d") {
    if (variant === "scaleX") {
      return "scaleX(" + (x.VAL.toString() + ")");
    } else if (variant === "scaleY") {
      return "scaleY(" + (x.VAL.toString() + ")");
    } else if (variant === "scaleZ") {
      return "scaleZ(" + (x.VAL.toString() + ")");
    } else {
      return "perspective(" + (x.VAL.toString() + ")");
    }
  }
  var match$5 = x.VAL;
  return string_of_translate3d(match$5[0], match$5[1], match$5[2]);
}

function transform(x) {
  return d("transform", string_of_transform(x));
}

function transforms(xs) {
  return d("transform", join(" ", List.map(string_of_transform, xs)));
}

function transformOrigin(x, y) {
  return d("transformOrigin", string_of_length(x) + (" " + string_of_length(y)));
}

function transformOrigin3d(x, y, z) {
  return d("transformOrigin", string_of_length(x) + (" " + (string_of_length(y) + (" " + (string_of_length(z) + " ")))));
}

function transformStyle(x) {
  return d("transformStyle", x === "preserve3d" ? "preserve-3d" : "flat");
}

function perspective(x) {
  var tmp;
  if (typeof x === "string") {
    tmp = x === "zero" ? "0" : "none";
  } else {
    var variant = x.NAME;
    if (variant === "pxFloat") {
      tmp = x.VAL.toString() + "px";
    } else if (variant === "vmax") {
      tmp = x.VAL.toString() + "vmax";
    } else if (variant === "vmin") {
      tmp = x.VAL.toString() + "vmin";
    } else if (variant === "percent") {
      tmp = x.VAL.toString() + "%";
    } else if (variant === "ch") {
      tmp = x.VAL.toString() + "ch";
    } else if (variant === "cm") {
      tmp = x.VAL.toString() + "cm";
    } else if (variant === "em") {
      tmp = x.VAL.toString() + "em";
    } else if (variant === "ex") {
      tmp = x.VAL.toString() + "ex";
    } else if (variant === "mm") {
      tmp = x.VAL.toString() + "mm";
    } else if (variant === "pt") {
      tmp = x.VAL.toString() + "pt";
    } else if (variant === "px") {
      tmp = x.VAL.toString() + "px";
    } else if (variant === "vh") {
      tmp = x.VAL.toString() + "vh";
    } else if (variant === "vw") {
      tmp = x.VAL.toString() + "vw";
    } else if (variant === "rem") {
      tmp = x.VAL.toString() + "rem";
    } else {
      var match = x.VAL;
      tmp = match[0] === "sub" ? "calc(" + (string_of_length(match[1]) + (" - " + (string_of_length(match[2]) + ")"))) : "calc(" + (string_of_length(match[1]) + (" + " + (string_of_length(match[2]) + ")")));
    }
  }
  return d("perspective", tmp);
}

function string_of_timingFunction(x) {
  if (typeof x === "string") {
    if (x === "easeInOut") {
      return "ease-in-out";
    } else if (x === "linear") {
      return "linear";
    } else if (x === "stepStart") {
      return "step-start";
    } else if (x === "stepEnd") {
      return "step-end";
    } else if (x === "easeIn" || x === "easeOut") {
      return "ease-out";
    } else {
      return "ease";
    }
  }
  if (x.NAME === "steps") {
    var match = x.VAL;
    var i = match[0];
    if (match[1] === "start") {
      return "steps(" + (i.toString() + ", start)");
    } else {
      return "steps(" + (i.toString() + ", end)");
    }
  }
  var match$1 = x.VAL;
  return "cubic-bezier(" + (match$1[0].toString() + (", " + (match$1[1].toString() + (", " + (match$1[2].toString() + (", " + (match$1[3].toString() + ")")))))));
}

function transition(durationOpt, delayOpt, timingFunctionOpt, property) {
  var duration = durationOpt !== undefined ? durationOpt : 0;
  var delay = delayOpt !== undefined ? delayOpt : 0;
  var timingFunction = timingFunctionOpt !== undefined ? timingFunctionOpt : "ease";
  return {
          NAME: "transition",
          VAL: duration.toString() + "ms " + (string_of_timingFunction(timingFunction) + (" " + (delay.toString() + "ms " + property)))
        };
}

function transitions(xs) {
  return d("transition", join(", ", List.map((function (x) {
                        return x.VAL;
                      }), xs)));
}

function transitionDelay(i) {
  return d("transitionDelay", i.toString() + "ms");
}

function transitionDuration(i) {
  return d("transitionDuration", i.toString() + "ms");
}

function transitionTimingFunction(x) {
  return d("transitionTimingFunction", string_of_timingFunction(x));
}

function transitionProperty(x) {
  return d("transitionProperty", x);
}

function perspectiveOrigin(x, y) {
  return d("perspectiveOrigin", string_of_length(x) + (" " + string_of_length(y)));
}

function string_of_animationDirection(x) {
  if (x === "alternateReverse") {
    return "alternate-reverse";
  } else if (x === "normal") {
    return "normal";
  } else if (x === "alternate") {
    return "alternate";
  } else {
    return "reverse";
  }
}

function string_of_animationFillMode(x) {
  if (x === "none") {
    return "none";
  } else if (x === "backwards") {
    return "backwards";
  } else if (x === "forwards") {
    return "forwards";
  } else {
    return "both";
  }
}

function string_of_animationIterationCount(x) {
  if (typeof x === "string") {
    return "infinite";
  } else {
    return x.VAL.toString();
  }
}

function string_of_animationPlayState(x) {
  if (x === "paused") {
    return "paused";
  } else {
    return "running";
  }
}

function animation(durationOpt, delayOpt, directionOpt, timingFunctionOpt, fillModeOpt, playStateOpt, iterationCountOpt, name) {
  var duration = durationOpt !== undefined ? durationOpt : 0;
  var delay = delayOpt !== undefined ? delayOpt : 0;
  var direction = directionOpt !== undefined ? directionOpt : "normal";
  var timingFunction = timingFunctionOpt !== undefined ? timingFunctionOpt : "ease";
  var fillMode = fillModeOpt !== undefined ? fillModeOpt : "none";
  var playState = playStateOpt !== undefined ? playStateOpt : "running";
  var iterationCount = iterationCountOpt !== undefined ? iterationCountOpt : ({
        NAME: "count",
        VAL: 1
      });
  return {
          NAME: "animation",
          VAL: name + (" " + (duration.toString() + "ms " + (string_of_timingFunction(timingFunction) + (" " + (delay.toString() + "ms " + (string_of_animationIterationCount(iterationCount) + (" " + (string_of_animationDirection(direction) + (" " + (string_of_animationFillMode(fillMode) + (" " + string_of_animationPlayState(playState))))))))))))
        };
}

function string_of_animation(x) {
  return x.VAL;
}

function animations(xs) {
  return d("animation", join(", ", List.map(string_of_animation, xs)));
}

function animationDelay(x) {
  return d("animationDelay", x.toString() + "ms");
}

function animationDirection(x) {
  return d("animationDirection", string_of_animationDirection(x));
}

function animationDuration(x) {
  return d("animationDuration", x.toString() + "ms");
}

function animationFillMode(x) {
  return d("animationFillMode", string_of_animationFillMode(x));
}

function animationIterationCount(x) {
  return d("animationIterationCount", string_of_animationIterationCount(x));
}

function animationName(x) {
  return d("animationName", x);
}

function animationPlayState(x) {
  return d("animationPlayState", string_of_animationPlayState(x));
}

function animationTimingFunction(x) {
  return d("animationTimingFunction", string_of_timingFunction(x));
}

function selector(selector$1, rules) {
  return {
          NAME: "selector",
          VAL: [
            selector$1,
            rules
          ]
        };
}

function active(param) {
  return selector(":active", param);
}

function after(param) {
  return selector("::after", param);
}

function before(param) {
  return selector("::before", param);
}

function checked(param) {
  return selector(":checked", param);
}

function children(param) {
  return selector(" > *", param);
}

function directSibling(param) {
  return selector(" + ", param);
}

function disabled(param) {
  return selector(":disabled", param);
}

function firstChild(param) {
  return selector(":first-child", param);
}

function firstOfType(param) {
  return selector(":first-of-type", param);
}

function focus(param) {
  return selector(":focus", param);
}

function hover(param) {
  return selector(":hover", param);
}

function lastChild(param) {
  return selector(":last-child", param);
}

function lastOfType(param) {
  return selector(":last-of-type", param);
}

function link(param) {
  return selector(":link", param);
}

function readOnly(param) {
  return selector(":read-only", param);
}

function required(param) {
  return selector(":required", param);
}

function visited(param) {
  return selector(":visited", param);
}

function enabled(param) {
  return selector(":enabled", param);
}

function noContent(param) {
  return selector(":empty", param);
}

function $$default(param) {
  return selector(":default", param);
}

function anyLink(param) {
  return selector(":any-link", param);
}

function onlyChild(param) {
  return selector(":only-child", param);
}

function onlyOfType(param) {
  return selector(":only-of-type", param);
}

function optional(param) {
  return selector(":optional", param);
}

function invalid(param) {
  return selector(":invalid", param);
}

function outOfRange(param) {
  return selector(":out-of-range", param);
}

function siblings(param) {
  return selector(" ~ ", param);
}

function target(param) {
  return selector(":target", param);
}

function firstLine(param) {
  return selector("::first-line", param);
}

function firstLetter(param) {
  return selector("::first-letter", param);
}

function selection(param) {
  return selector("::selection", param);
}

function placeholder(param) {
  return selector("::placeholder", param);
}

function media(query, rules) {
  return {
          NAME: "selector",
          VAL: [
            "@media " + query,
            rules
          ]
        };
}

function fill(color) {
  return d("fill", string_of_color(color));
}

function fillOpacity(opacity) {
  return d("fillOpacity", opacity.toString());
}

function fillRule(x) {
  return d("fillRule", x === "evenodd" ? "evenodd" : "nonzero");
}

function stroke(color) {
  return d("stroke", string_of_color(color));
}

function strokeWidth(length) {
  return d("strokeWidth", string_of_length(length));
}

function strokeOpacity(opacity) {
  return d("strokeOpacity", opacity.toString());
}

function strokeMiterlimit(x) {
  return d("strokeMiterlimit", x.toString());
}

function strokeLinecap(x) {
  return d("strokeLinecap", x === "square" ? "square" : (
                x === "round" ? "round" : "butt"
              ));
}

function strokeLinejoin(x) {
  return d("strokeLinejoin", x === "miter" ? "miter" : (
                x === "bevel" ? "bevel" : "round"
              ));
}

function stopColor(c) {
  return d("stopColor", string_of_color(c));
}

function stopOpacity(o) {
  return d("stopOpacity", o.toString());
}

var SVG = {
  fill: fill,
  fillOpacity: fillOpacity,
  fillRule: fillRule,
  stroke: stroke,
  strokeWidth: strokeWidth,
  strokeOpacity: strokeOpacity,
  strokeMiterlimit: strokeMiterlimit,
  strokeLinecap: strokeLinecap,
  strokeLinejoin: strokeLinejoin,
  stopColor: stopColor,
  stopOpacity: stopOpacity
};

var empty = /* [] */0;

var initial = "initial";

var inherit_ = "inherit_";

var unset = "unset";

var rtl = "rtl";

var ltr = "ltr";

var zero = "zero";

var horizontal = "horizontal";

var vertical = "vertical";

var absolute = "absolute";

var all = "all";

var auto = "auto";

var backwards = "backwards";

var baseline = "baseline";

var borderBox = "borderBox";

var both = "both";

var center = "center";

var column = "column";

var columnReverse = "columnReverse";

var contain = "contain";

var contentBox = "contentBox";

var cover = "cover";

var dashed = "dashed";

var dotted = "dotted";

var ease = "ease";

var easeIn = "easeIn";

var easeInOut = "easeInOut";

var easeOut = "easeOut";

var fixed = "fixed";

var flexEnd = "flexEnd";

var flexStart = "flexStart";

var forwards = "forwards";

var hidden = "hidden";

var infinite = "infinite";

var inline = "inline";

var block = "block";

var contents = "contents";

var flexBox = "flex";

var grid = "grid";

var inlineBlock = "inlineBlock";

var inlineFlex = "inlineFlex";

var inlineGrid = "inlineGrid";

var inlineTable = "inlineTable";

var listItem = "listItem";

var runIn = "runIn";

var table = "table";

var tableCaption = "tableCaption";

var tableColumnGroup = "tableColumnGroup";

var tableHeaderGroup = "tableHeaderGroup";

var tableFooterGroup = "tableFooterGroup";

var tableRowGroup = "tableRowGroup";

var tableCell = "tableCell";

var tableColumn = "tableColumn";

var tableRow = "tableRow";

var linear = "linear";

var local = "local";

var none = "none";

var noRepeat = "noRepeat";

var nowrap = "nowrap";

var paddingBox = "paddingBox";

var paused = "paused";

var relative = "relative";

var repeat = "repeat";

var minmax = "minmax";

var repeatX = "repeatX";

var repeatY = "repeatY";

var row = "row";

var rowReverse = "rowReverse";

var running = "running";

var scroll = "scroll";

var solid = "solid";

var spaceAround = "spaceAround";

var spaceBetween = "spaceBetween";

var spaceEvenly = "spaceEvenly";

var $$static = "static";

var stepEnd = "stepEnd";

var stepStart = "stepStart";

var sticky = "sticky";

var stretch = "stretch";

var text = "text";

var visible = "visible";

var wrap = "wrap";

var wrapReverse = "wrapReverse";

var inside = "inside";

var outside = "outside";

var italic = "italic";

var oblique = "oblique";

var underline = "underline";

var overline = "overline";

var lineThrough = "lineThrough";

var clip = "clip";

var ellipsis = "ellipsis";

var wavy = "wavy";

var $$double = "double";

var uppercase = "uppercase";

var lowercase = "lowercase";

var capitalize = "capitalize";

var sub = "sub";

var $$super = "super";

var textTop = "textTop";

var textBottom = "textBottom";

var middle = "middle";

var normal = "normal";

var breakAll = "breakAll";

var keepAll = "keepAll";

var breakWord = "breakWord";

var reverse = "reverse";

var alternate = "alternate";

var alternateReverse = "alternateReverse";

var fill$1 = "fill";

var content = "content";

var maxContent = "maxContent";

var minContent = "minContent";

var fitContent = "fitContent";

var round = "round";

var miter = "miter";

var bevel = "bevel";

var butt = "butt";

var square = "square";

var unsafe = d;

var thin = "thin";

var extraLight = "extraLight";

var light = "light";

var medium = "medium";

var semiBold = "semiBold";

var bold = "bold";

var extraBold = "extraBold";

var lighter = "lighter";

var bolder = "bolder";

export {
  style ,
  join ,
  string_of_float ,
  string_of_int ,
  Converter ,
  string_of_length ,
  string_of_angle ,
  string_of_rgb ,
  string_of_rgba ,
  string_of_p3 ,
  string_of_percent ,
  string_of_hsl ,
  string_of_alpha ,
  string_of_color ,
  string_of_stops ,
  string_of_linearGradient ,
  string_of_repeatingLinearGradient ,
  string_of_translate3d ,
  string_of_scale ,
  string_of_time ,
  string_of_overflow ,
  string_of_visibility ,
  string_of_background ,
  string_of_cursor ,
  string_of_fontWeight ,
  string_of_fontStyle ,
  string_of_flex ,
  string_of_flexBasis ,
  empty ,
  d ,
  important ,
  label ,
  initial ,
  inherit_ ,
  unset ,
  rtl ,
  ltr ,
  deg ,
  rad ,
  grad ,
  turn ,
  pct ,
  rgb ,
  rgba ,
  linearGradient ,
  repeatingLinearGradient ,
  radialGradient ,
  repeatingRadialGradient ,
  string_of_length_cascading ,
  ch ,
  cm ,
  em ,
  ex ,
  fr ,
  mm ,
  pt ,
  px ,
  pxFloat ,
  rem ,
  vh ,
  vmax ,
  vmin ,
  vw ,
  zero ,
  Calc ,
  size ,
  resize ,
  horizontal ,
  vertical ,
  absolute ,
  all ,
  auto ,
  backwards ,
  baseline ,
  borderBox ,
  both ,
  center ,
  column ,
  columnReverse ,
  contain ,
  contentBox ,
  count ,
  cover ,
  cubicBesier ,
  dashed ,
  dotted ,
  ease ,
  easeIn ,
  easeInOut ,
  easeOut ,
  fixed ,
  flexEnd ,
  flexStart ,
  forwards ,
  hidden ,
  infinite ,
  inline ,
  block ,
  contents ,
  flexBox ,
  grid ,
  inlineBlock ,
  inlineFlex ,
  inlineGrid ,
  inlineTable ,
  listItem ,
  runIn ,
  table ,
  tableCaption ,
  tableColumnGroup ,
  tableHeaderGroup ,
  tableFooterGroup ,
  tableRowGroup ,
  tableCell ,
  tableColumn ,
  tableRow ,
  linear ,
  local ,
  localUrl ,
  none ,
  noRepeat ,
  nowrap ,
  paddingBox ,
  paused ,
  relative ,
  repeat ,
  minmax ,
  repeatX ,
  repeatY ,
  rotate ,
  rotate3d ,
  rotateX ,
  rotateY ,
  rotateZ ,
  row ,
  rowReverse ,
  running ,
  scale ,
  scale3d ,
  scaleX ,
  scaleY ,
  scaleZ ,
  scroll ,
  skew ,
  skewX ,
  skewY ,
  solid ,
  spaceAround ,
  spaceBetween ,
  spaceEvenly ,
  $$static ,
  stepEnd ,
  steps ,
  stepStart ,
  sticky ,
  stretch ,
  text ,
  translate ,
  translate3d ,
  translateX ,
  translateY ,
  translateZ ,
  url ,
  visible ,
  wrap ,
  wrapReverse ,
  inside ,
  outside ,
  italic ,
  oblique ,
  underline ,
  overline ,
  lineThrough ,
  clip ,
  ellipsis ,
  wavy ,
  $$double ,
  uppercase ,
  lowercase ,
  capitalize ,
  sub ,
  $$super ,
  textTop ,
  textBottom ,
  middle ,
  normal ,
  breakAll ,
  keepAll ,
  breakWord ,
  reverse ,
  alternate ,
  alternateReverse ,
  fill$1 as fill,
  content ,
  maxContent ,
  minContent ,
  fitContent ,
  round ,
  miter ,
  bevel ,
  butt ,
  square ,
  unsafe ,
  display ,
  position ,
  top ,
  bottom ,
  left ,
  right ,
  flex ,
  flex3 ,
  flexGrow ,
  flexShrink ,
  flexBasis ,
  flexDirection ,
  flexWrap ,
  order ,
  string_of_margin ,
  margin ,
  margin2 ,
  margin3 ,
  margin4 ,
  marginLeft ,
  marginRight ,
  marginTop ,
  marginBottom ,
  padding ,
  padding2 ,
  padding3 ,
  padding4 ,
  paddingLeft ,
  paddingRight ,
  paddingTop ,
  paddingBottom ,
  string_of_minmax ,
  string_of_dimension ,
  width ,
  height ,
  minWidth ,
  maxWidth ,
  minHeight ,
  maxHeight ,
  gridAutoDirectionToJs ,
  gridAutoFlow ,
  repeatValueToJs ,
  gridLengthToJs ,
  string_of_dimensions ,
  gridTemplateColumns ,
  gridTemplateRows ,
  gridAutoColumns ,
  gridAutoRows ,
  gridColumn ,
  gridRow ,
  gridColumnStart ,
  gridColumnEnd ,
  gridRowStart ,
  gridRowEnd ,
  gridColumnGap ,
  gridRowGap ,
  gridGap ,
  string_of_align ,
  alignItems ,
  alignSelf ,
  string_of_justify ,
  justifyContent ,
  justifySelf ,
  alignContent ,
  boxSizing ,
  $$float ,
  clear ,
  overflow ,
  overflowX ,
  overflowY ,
  zIndex ,
  contentRule ,
  columnCount ,
  direction ,
  string_of_filter ,
  filter ,
  backfaceVisibility ,
  visibility ,
  boxShadow ,
  string_of_shadow ,
  boxShadows ,
  string_of_borderstyle ,
  border ,
  borderWidth ,
  borderStyle ,
  borderColor ,
  borderLeft ,
  borderLeftWidth ,
  borderLeftStyle ,
  borderLeftColor ,
  borderRight ,
  borderRightWidth ,
  borderRightColor ,
  borderRightStyle ,
  borderTop ,
  borderTopWidth ,
  borderTopStyle ,
  borderTopColor ,
  borderBottom ,
  borderBottomWidth ,
  borderBottomStyle ,
  borderBottomColor ,
  borderRadius ,
  borderTopLeftRadius ,
  borderTopRightRadius ,
  borderBottomLeftRadius ,
  borderBottomRightRadius ,
  tableLayout ,
  borderCollapse ,
  borderSpacing ,
  background ,
  backgrounds ,
  backgroundColor ,
  backgroundImage ,
  backgroundAttachment ,
  backgroundClip ,
  backgroundOrigin ,
  backgroundPosition ,
  backgroundRepeat ,
  backgroundSize ,
  cursor ,
  clipPath ,
  string_of_listStyleType ,
  string_of_listStylePosition ,
  string_of_listStyleImage ,
  listStyle ,
  listStyleType ,
  listStylePosition ,
  listStyleImage ,
  opacity ,
  string_of_outlineStyle ,
  outline ,
  outlineStyle ,
  outlineWidth ,
  outlineColor ,
  outlineOffset ,
  thin ,
  extraLight ,
  light ,
  medium ,
  semiBold ,
  bold ,
  extraBold ,
  lighter ,
  bolder ,
  color ,
  fontFamily ,
  fontSize ,
  fontVariant ,
  fontStyle ,
  fontWeight ,
  lineHeight ,
  letterSpacing ,
  textAlign ,
  textDecoration ,
  textDecorationColor ,
  textDecorationStyle ,
  textIndent ,
  textOverflow ,
  textShadow ,
  string_of_textShadow ,
  textShadows ,
  textTransform ,
  userSelect ,
  verticalAlign ,
  whiteSpace ,
  wordBreak ,
  wordSpacing ,
  wordWrap ,
  string_of_pointerEvents ,
  pointerEvents ,
  string_of_transform ,
  transform ,
  transforms ,
  transformOrigin ,
  transformOrigin3d ,
  transformStyle ,
  perspective ,
  string_of_timingFunction ,
  transition ,
  transitions ,
  transitionDelay ,
  transitionDuration ,
  transitionTimingFunction ,
  transitionProperty ,
  perspectiveOrigin ,
  string_of_animationDirection ,
  string_of_animationFillMode ,
  string_of_animationIterationCount ,
  string_of_animationPlayState ,
  animation ,
  string_of_animation ,
  animations ,
  animationDelay ,
  animationDirection ,
  animationDuration ,
  animationFillMode ,
  animationIterationCount ,
  animationName ,
  animationPlayState ,
  animationTimingFunction ,
  selector ,
  active ,
  after ,
  before ,
  checked ,
  children ,
  directSibling ,
  disabled ,
  firstChild ,
  firstOfType ,
  focus ,
  hover ,
  lastChild ,
  lastOfType ,
  link ,
  readOnly ,
  required ,
  visited ,
  enabled ,
  noContent ,
  $$default ,
  $$default as default,
  anyLink ,
  onlyChild ,
  onlyOfType ,
  optional ,
  invalid ,
  outOfRange ,
  siblings ,
  target ,
  firstLine ,
  firstLetter ,
  selection ,
  placeholder ,
  media ,
  SVG ,
  
}
/* No side effect */
